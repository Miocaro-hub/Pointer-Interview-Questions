#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>


//1.执行的结果是什么
int main()
{
	int a[5] = { 1,2,3,4,5 };
	int* ptr = (int*)(&a + 1);
	printf("%d,%d\n", *(a + 1), *(ptr - 1));
	//结果为2,5
	//&a+1是跳过了一个数组的地址,再强制类型转换,存入ptr中,而ptr-1是后退了一个整型
	//*(ptr-1)就指向第五个元素,结果为5
	printf("\n");
	return 0;
}

//2.假设p的值为0x100000,如下表达式的值分别为多少?
//已知,结构体Test类型的变量大小是20个字节
struct Test
{
	int Num;
	char *pcName;
	short sDate;
	char cha[2];
	short sBa[4];
}*p; //结构体指针

int main()
{
	p = (struct Test*)0x100000;
	printf("%p\n", p + 0x1); //0x00100014(前两个0没意义) - 结构体指针+1,跳过一个结构体的内存,为20个字节
	printf("%p\n", (unsigned long)p + 0x1); //0x00100001 - 跳过一个无符号long类型,一个字节
	printf("%p\n", (unsigned int*)p + 0x1); //0x00100004 - 跳过一个无符号整型指针,四个字节
	//指针+ - 整数取决于指针的类型
	return 0;
}


//3.执行的结果是什么
int main()
{
	int a[4] = { 1,2,3,4 };
	//小端存储模式,此时数组a的存储为01 00 00 00 / 02 00 00 00 / 03 00 00 00 / 04 00 00 00
	
	int *ptr1 = (int*)(&a + 1);//&a+1跳过一整个数组的地址
	int *ptr2 = (int*)((int)a + 1);//将a强制转换为int类型再+1(就是数字+1,反应到地址上就是向后了一个字节),然后再强制转换成int*类型,本质上就是差了一个字节
	//假设地址为0x00000005,+1后变成了0x00000006
    //01 00 00 00 / 02 00 00 00 / 03 00 00 00 / 04 00 00 00
	//|->|(指针指向了这里)
	//从指针位置向后读4个字节,就是 00 00 00 02

	printf("%x\n", ptr1[-1]); //0x4 - ptr1[-1] == ptr1+(-1) == ptr -1
	printf("%x\n", *ptr2); //00 00 00 02再解引用,就为0x 02 00 00 00
	//所以输入结果就为2000000(省略前面一个0)
	return 0;
}


//4.执行结果是什么
int main()
{
	int a[3][2] = { (0,1),(2,3),(4,5) }; //逗号表达式,只执行最后的结果(真坑),实际上存入的内容为{1,3,5,0,0,0};
	int *p;
	p = a[0]; //a[0]赋给p的就是第一行第一个元素的地址
	printf("%d\n", p[0]); //输出结果为1
	return 0;
}


//5.执行结果是什么
int main()
{
	int a[5][5];
	int(*p)[4]; //指向数组的指针,数组中有4个元素,类型为整型
	p = a;//p的类型为int(*)[4],a的类型为int(*)[5],类型不一样,会报警告
	//把地址赋给p,p还是指向数组a的第一个元素

	//p[4][2] == *(p[4]+2) == *(*(p+4)+2),因为p是整型指针,+1跳过4个元素,+2就跳过8个元素,p[]+2跳过2个元素
	//p[4]指向的是a数组中第4行第2个元素
	//所以p[4][2]此时指向的是a数组中第4行第4个元素
	//&a[4][2]为第5行第3个元素
	printf("%p\n", &p[4][2] - &a[4][2]);//指针和指针相减(地址和地址),若以%d的形式打印,结果为-4,但此时为%p的形式,直接打印-4的补码(在计算中不需要再转换成原码)
	printf("%d\n", &p[4][2] - &a[4][2]);//-4

	//所以分别输出的值为0xfffffffc,-4
	return 0;
}